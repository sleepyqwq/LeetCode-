# 十四. 贪心

## 买股票的最佳时机

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 

**示例 1：**

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票

**解答：**

遍历数组，从第一天开始，如果今天股价比昨天低，那显然今天买才可能不亏，将今天记录为最低价

如果今天价格比最低价买的高，算一下今天能卖的话能赚多少（也就是求最大利润）

cpp：

```cpp
class Solution {
  public:
    int maxProfit(vector<int> &prices) {
        int minm = prices[0], ans = 0;
        for (int i = 1; i < prices.size(); i++) {
            if (prices[i] <= minm)
                minm = prices[i];
            else
                ans = max(prices[i] - minm, ans);
        }
        return ans;
    }
};
```

java：

```java
public class Solution {
    public int maxProfit(int[] prices) {
        int maxprofit = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                int profit = prices[j] - prices[i];
                if (profit > maxprofit) {
                    maxprofit = profit;
                }
            }
        }
        return maxprofit;
    }
}
```

## 跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 

**示例 1：**

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标

**解答：**

遍历数组，找到当前能够到达的最远位置 far，如果当前位置 i 已经大于far，那显然这个位置以及后面的所有位置都到不了

否则更新`far = max(far, i + nums[i])`

cpp：

```cpp
class Solution {
  public:
    bool canJump(vector<int> &nums) {
        int far = 0;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            if (i > far)
                return false;
            far = max(far, i + nums[i]);
            if (far >= n - 1)
                return true;
        }
        return true;
    }
};
```

java：

```java
public class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = Math.max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

## 跳跃游戏2

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`，初始位置在下标 0

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度

换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：

- `0 <= j <= nums[i]` 且`i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`

**示例 1:**

输入: nums = [2,3,1,1,4]
输出: 2
解释: 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置

**解答：**

end 表示当前这一次跳跃能够覆盖到的最远边界

far 表示在当前这一层扫描过程中，下一次跳跃能到达的最远位置

当 i 走到 end，说明这一层能覆盖的位置都扫描完了，必须再跳一次，把 end 更新为 far

cpp：

```cpp
class Solution {
  public:
    int jump(vector<int> &nums) {
        int n = nums.size();
        if (n == 1)
            return 0;
        int ans = 0, end = 0, far = 0;
        for (int i = 0; i < n; i++) {
            far = max(far, i + nums[i]);
            if (i == end) {
                ans++;
                end = far;
                if (end >= n - 1)
                    return ans;
            }
        }
        return ans;
    }
};
```

java：

```java
class Solution {
    public int jump(int[] nums) {
        int length = nums.length;
        int end = 0;
        int maxPosition = 0; 
        int steps = 0;
        for (int i = 0; i < length - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]); 
            if (i == end) {
                end = maxPosition;
                steps++;
            }
        }
        return steps;
    }
}
```

## 划分字母区间

给你一个字符串 `s` ，我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中

例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]` 的划分是非法的

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 

返回一个表示每个字符串片段的长度的列表

示例 1：

输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 
每个字母最多出现在一个片段中
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少

**解答：**

先记录每个字符在字符串中最后一次出现的位置 last

然后从左到右扫描，维护当前片段的最右边界 end

当扫描到位置 i 时，用 end = max(end, last[s[i]]) 更新边界

如果 i == end，说明从当前片段起点到 end 的所有字符，其最后出现位置都不超过 end，片段可以在这里结束

记录长度并开始下一个片段

cpp：

```cpp
class Solution {
  public:
    vector<int> partitionLabels(string s) {
        vector<int> last(26, -1);
        int n = s.size();

        for (int i = 0; i < n; ++i)
            last[s[i] - 'a'] = i;

        vector<int> ans;
        int start = 0, end = 0;

        for (int i = 0; i < n; ++i) {
            end = max(end, last[s[i] - 'a']);
            if (i == end) {
                ans.push_back(end - start + 1);
                start = i + 1;
            }
        }
        return ans;
    }
};
```

java：

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        int length = s.length();
        for (int i = 0; i < length; i++) {
            last[s.charAt(i) - 'a'] = i;
        }
        List<Integer> partition = new ArrayList<Integer>();
        int start = 0, end = 0;
        for (int i = 0; i < length; i++) {
            end = Math.max(end, last[s.charAt(i) - 'a']);
            if (i == end) {
                partition.add(end - start + 1);
                start = end + 1;
            }
        }
        return partition;
    }
}
```

# 十五. 动态规划

## 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶

**解答：**

cpp：

```cpp
class Solution {
public:
    int climbStairs(int n) {
        int p = 0, q = 0, r = 1;
        for (int i = 1; i <= n; ++i) {
            p = q; 
            q = r; 
            r = p + q;
        }
        return r;
    }
};
```

java：

```java
class Solution {
    public int climbStairs(int n) {
        int p = 0, q = 0, r = 1;
        for (int i = 1; i <= n; ++i) {
            p = q; 
            q = r; 
            r = p + q;
        }
        return r;
    }
}
```

## 杨辉三角

给定一个非负整数 *numRows，*生成「杨辉三角」的前 *numRows* 行

在**「杨辉三角」**中，每个数是它左上方和右上方的数的和。

**示例 1:**

输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

**解答：**

cpp：

```cpp
class Solution {
  public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> ans;
        ans.resize(numRows);
        for (int i = 0; i < numRows; i++) {
            for (int j = 0; j <= i; j++) {
                if (j == 0 || j == i)
                    ans[i].push_back(1);
                else
                    ans[i].push_back(ans[i - 1][j - 1] + ans[i - 1][j]);
            }
        }
        return ans;
    }
};
```

java：

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        for (int i = 0; i < numRows; ++i) {
            List<Integer> row = new ArrayList<Integer>();
            for (int j = 0; j <= i; ++j) {
                if (j == 0 || j == i) {
                    row.add(1);
                } else {
                    row.add(ret.get(i - 1).get(j - 1) + ret.get(i - 1).get(j));
                }
            }
            ret.add(row);
        }
        return ret;
    }
}
```

## 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额

**示例 2：**

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)
     偷窃到的最高金额 = 2 + 9 + 1 = 12

**解答：**

定义：dp[i] 表示偷到第 i 间房为止能获得的最高金额

那么第 i 间房只有两种选择：

不偷第 i 间房，金额为 dp[i-1]

偷第 i 间房，金额为 dp[i-2] + nums[i]

cpp：

```cpp
class Solution {
  public:
    int rob(vector<int> &nums) {
        int n = nums.size();
        if (n == 1)
            return nums[0];
        int x = nums[0];
        int ans = max(nums[0], nums[1]);
        for (int i = 2; i < n; ++i) {
            int tmp = max(ans, x + nums[i]);
            x = ans;
            ans = tmp;
        }
        return ans;
    }
};
```

java：

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int length = nums.length;
        if (length == 1) {
            return nums[0];
        }
        int first = nums[0], second = Math.max(nums[0], nums[1]);
        for (int i = 2; i < length; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```

## 完全平方数

给你一个整数 `n` ，返回和为 n 的完全平方数的最少数量

**完全平方数** 是一个整数，其值等于另一个整数的平方，例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是

**示例 1：**

输入：n = 13
输出：2
解释：13 = 4 + 9

**解答：**

设 dp[i] 表示和为 i 的完全平方数的最少数量。

枚举最后一个选用的平方数 j*j

转移方程

dp[i] = min(dp[i], dp[i - j*j] + 1)

cpp：

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;

        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j * j <= i; ++j) {
                int sq = j * j;
                if (dp[i - sq] != INT_MAX) {
                    dp[i] = min(dp[i], dp[i - sq] + 1);
                }
            }
        }
        return dp[n];
    }
};
```

java：

```java
class Solution {
    public int numSquares(int n) {
        int[] f = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            int minn = Integer.MAX_VALUE;
            for (int j = 1; j * j <= i; j++) {
                minn = Math.min(minn, f[i - j * j]);
            }
            f[i] = minn + 1;
        }
        return f[n];
    }
}
```

## 零钱兑换

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 

你可以认为每种硬币的数量是无限的

**示例 1：**

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1

**解答：**

设 dp[i] 表示凑成金额 i 所需的最少硬币数。
那么对于每个金额 i，如果选择一枚面额为 c 的硬币，只要 i >= c，
就可以从 dp[i - c] 转移过来

状态转移方程
dp[i] = min(dp[i], dp[i - c] + 1)

初始化
dp[0] = 0
其余 dp[i] 设为一个不可能的大值，例如 amount + 1

cpp：

```cpp
class Solution {
  public:
    int coinChange(vector<int> &coins, int amount) {
        if (!amount)
            return 0;
        const int MAX = amount + 1;
        vector<int> dp(MAX, MAX);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++)
            for (int c : coins)
                if (i >= c)
                    dp[i] = min(dp[i], dp[i - c] + 1);
        return (dp[amount] > amount) ? -1 : dp[amount];
    }
};
```

java：

```java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

## 单词拆分

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 2：**

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
注意，你可以重复使用字典中的单词。

**解答：**

设 `dp[i]` 表示字符串 `s` 的前 `i` 个字符（即 `s[0..i-1]`）是否可以由字典单词拼接得到。

- `dp[0]=true` 表示空串可被“拼接”出来。
- 对于每个 `i`，枚举切分点 `j`：
  如果 `dp[j]=true` 且 `s[j..i-1]` 在字典中，则 `dp[i]=true`。

为了加速判断子串是否在字典中，将 `wordDict` 放入 `unordered_set`。
还可以记录字典中单词的最大长度 `maxLen`，这样每次只需要检查长度不超过 `maxLen` 的区间，减少无效枚举。

cpp：

```cpp
class Solution {
  public:
    bool wordBreak(string s, vector<string> &wordDict) {
        unordered_set<string> dict;
        dict.reserve(wordDict.size() * 2);
        int maxLen = 0;
        for (const auto &c : wordDict) {
            dict.insert(c);
            if (c.size() > maxLen)
                maxLen = c.size();
        }
        int n = s.size();
        vector<bool> dp(n + 1, false);
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            int start = max(0, i - maxLen); 
            for (int j = i - 1; j >= start; j--) {
                if (!dp[j])
                    continue;
                if (dict.count(s.substr(j, i - j))) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[n];
    }
};
```

java：

```java
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```





